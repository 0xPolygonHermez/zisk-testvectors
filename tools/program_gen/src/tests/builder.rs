use std::fs::File;
use std::io::{BufWriter, Write};

use super::config::ProgramConfig;

pub struct ProgramBuilder {
    config: ProgramConfig,
    test_groups: Vec<TestGroup>,
}

struct TestGroup {
    name: String,
    header_sections: Vec<String>,
    test_functions: Vec<TestFunction>,
}

struct TestFunction {
    name: String,
    body_lines: Vec<String>,
}

impl ProgramBuilder {
    pub fn new(config: ProgramConfig) -> Self {
        Self { config, test_groups: vec![] }
    }

    pub fn add_test_group(&mut self, name: &str) {
        self.test_groups.push(TestGroup {
            name: name.to_string(),
            header_sections: vec![],
            test_functions: vec![],
        });
    }

    pub fn add_header_to_current_group(&mut self, lines: &[&str]) {
        if let Some(group) = self.test_groups.last_mut() {
            for line in lines {
                group.header_sections.push(line.to_string());
            }
        }
    }

    pub fn add_test_to_current_group(&mut self, name: &str, body_lines: &[&str]) {
        if let Some(group) = self.test_groups.last_mut() {
            group.test_functions.push(TestFunction {
                name: name.to_string(),
                body_lines: body_lines.iter().map(|s| s.to_string()).collect(),
            });
        }
    }

    pub fn generate_to_file(&self, file_path: &str) {
        let file = File::create(file_path).expect("Failed to create test file");
        let mut writer = BufWriter::new(file);

        self.write_file_header(&mut writer);
        self.write_test_groups(&mut writer);
        self.write_file_footer(&mut writer);

        writer.flush().expect("Failed to flush test file");
        println!("Generated test file: {}", file_path);
    }

    fn write_file_header(&self, writer: &mut BufWriter<File>) {
        writeln!(writer, "//! Generated test file for {}.", self.config.module_name).unwrap();
        writeln!(writer, "//! DO NOT EDIT - This file is automatically generated.").unwrap();
        writeln!(writer, "").unwrap();

        writeln!(writer, "#![no_main]").unwrap();
        writeln!(writer, "#![cfg(all(target_os = \"zkvm\", target_vendor = \"zisk\"))]").unwrap();
        writeln!(writer, "ziskos::entrypoint!(main);").unwrap();
        writeln!(writer, "").unwrap();

        writeln!(writer, "use ziskos::{{syscalls::*, zisklib::*}};").unwrap();
        writeln!(writer, "").unwrap();

        writeln!(writer, "fn main() {{").unwrap();
    }

    // fn write_test_header(&self, writer: &mut BufWriter<File>) {
    //     writeln!(writer, "\t//////////////",).unwrap();
    //     writeln!(writer, "\t// Tests {}", self.config.module_name).unwrap();
    //     writeln!(writer, "\t//////////////",).unwrap();
    //     writeln!(writer, "").unwrap();
    //     if !self.header_sections.is_empty() {
    //         for header_line in &self.header_sections {
    //             writeln!(writer, "\t{}", header_line).unwrap();
    //         }
    //         writeln!(writer, "").unwrap();
    //     }
    // }

    // fn write_test_functions(&self, writer: &mut BufWriter<File>) {
    //     for (i, test_func) in self.test_functions.iter().enumerate() {
    //         writeln!(writer, "\t// #{i}: {}", test_func.name).unwrap();
    //         for line in &test_func.body_lines {
    //             writeln!(writer, "\t{}", line).unwrap();
    //         }
    //         writeln!(writer, "").unwrap();
    //     }
    // }

    fn write_test_groups(&self, writer: &mut BufWriter<File>) {
        for group in &self.test_groups {
            writeln!(writer, "\t//////////////").unwrap();
            writeln!(writer, "\t// {}", group.name).unwrap();
            writeln!(writer, "\t//////////////").unwrap();
            writeln!(writer, "").unwrap();

            // Write header sections for this group
            if !group.header_sections.is_empty() {
                for header_line in &group.header_sections {
                    writeln!(writer, "\t{}", header_line).unwrap();
                }
                writeln!(writer, "").unwrap();
            }

            // Write test functions for this group
            for (i, test_func) in group.test_functions.iter().enumerate() {
                writeln!(writer, "\t// Test #{}: {}", i, test_func.name).unwrap();
                for line in &test_func.body_lines {
                    writeln!(writer, "\t{}", line).unwrap();
                }
                writeln!(writer, "").unwrap();
            }
        }
    }

    fn write_file_footer(&self, writer: &mut BufWriter<File>) {
        writeln!(writer, "}}").unwrap();
    }
}
