use std::fs::File;
use std::io::{BufWriter, Write};

pub struct ProgramBuilder {
    program_name: String,
    test_groups: Vec<TestGroup>,
}

struct TestGroup {
    name: String,
    header_sections: Vec<String>,
    test_functions: Vec<TestFunction>,
}

struct TestFunction {
    name: String,
    body_lines: Vec<String>,
}

impl ProgramBuilder {
    pub fn new(program_name: &str) -> Self {
        Self { program_name: program_name.to_string(), test_groups: vec![] }
    }

    pub fn add_test_group(&mut self, name: &str) {
        self.test_groups.push(TestGroup {
            name: name.to_string(),
            header_sections: vec![],
            test_functions: vec![],
        });
    }

    pub fn add_header_to_current_group(&mut self, lines: &[&str]) {
        if let Some(group) = self.test_groups.last_mut() {
            for line in lines {
                group.header_sections.push(line.to_string());
            }
        }
    }

    pub fn add_test_to_current_group(&mut self, name: &str, body_lines: &[&str]) {
        if let Some(group) = self.test_groups.last_mut() {
            group.test_functions.push(TestFunction {
                name: name.to_string(),
                body_lines: body_lines.iter().map(|s| s.to_string()).collect(),
            });
        }
    }

    pub fn generate_to_file(&self, file_path: &str, fn_name: &str) {
        let file = File::create(file_path).expect("Failed to create test file");
        let mut writer = BufWriter::new(file);

        self.write_file_header(&mut writer, fn_name);
        self.write_test_groups(&mut writer);
        self.write_file_footer(&mut writer);

        writer.flush().expect("Failed to flush test file");
    }

    fn write_file_header(&self, writer: &mut BufWriter<File>, fn_name: &str) {
        writeln!(writer, "//! Generated test file for {}.", self.program_name).unwrap();
        writeln!(writer, "//! DO NOT EDIT - This file is automatically generated.").unwrap();
        writeln!(writer).unwrap();

        writeln!(writer, "use ziskos::{{syscalls::*, zisklib::*}};").unwrap();
        writeln!(writer).unwrap();

        writeln!(writer, "pub fn {}() {{", fn_name).unwrap();
    }

    fn write_test_groups(&self, writer: &mut BufWriter<File>) {
        for group in &self.test_groups {
            writeln!(writer, "\t//////////////").unwrap();
            writeln!(writer, "\t// {}", group.name).unwrap();
            writeln!(writer, "\t//////////////").unwrap();
            writeln!(writer).unwrap();

            // Write header sections for this group
            if !group.header_sections.is_empty() {
                for header_line in &group.header_sections {
                    writeln!(writer, "\t{}", header_line).unwrap();
                }
                writeln!(writer).unwrap();
            }

            // Write test functions for this group
            for (i, test_func) in group.test_functions.iter().enumerate() {
                writeln!(writer, "\t// Test #{}: {}", i, test_func.name).unwrap();
                for line in &test_func.body_lines {
                    writeln!(writer, "\t{}", line).unwrap();
                }
                writeln!(writer).unwrap();
            }
        }
    }

    fn write_file_footer(&self, writer: &mut BufWriter<File>) {
        writeln!(writer, "}}").unwrap();
    }
}
